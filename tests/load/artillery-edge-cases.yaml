##
## Artillery Edge Case Tests — Failure Injection & Resilience
##
## Lower concurrency, targeted failure scenarios:
##   - Reorg simulation (create → bid → cancel → re-bid)
##   - Cache bypass (force DB hits during load)
##   - Chainlink stub latency > 5s
##   - Concurrent auto-bid budget drain (50 evaluations in < 1s)
##   - Webhook delivery failure cascade
##
## Usage: npx artillery run tests/load/artillery-edge-cases.yaml
##

config:
  target: "http://localhost:3001"
  phases:
    # Lower concurrency — focused on correctness under failure
    - duration: 30
      arrivalRate: 10
      name: "Warm-up"
    - duration: 60
      arrivalRate: 50
      rampTo: 200
      name: "Ramp to failure threshold"
    - duration: 120
      arrivalRate: 500
      name: "Sustained failure injection"
    - duration: 30
      arrivalRate: 50
      name: "Cool-down"

  processor: "./artillery-processor.js"

  plugins:
    expect: {}

  defaults:
    headers:
      Content-Type: "application/json"
      Authorization: "Bearer {{ $processEnvironment.TEST_API_TOKEN }}"

  ensure:
    thresholds:
      - http.response_time.p99: 5000   # Relaxed for failure scenarios
    conditions:
      - expression: "http.response_time.p99 < 5000"
        strict: false                    # Advisory, not hard fail

scenarios:
  # ─── 1. Reorg Simulation ───────────────────────
  # Create lead → bid → attempt cancel → re-bid on same lead
  # Validates state consistency under rapid state changes
  - name: "Reorg: Create → Bid → Cancel → Re-Bid"
    weight: 25
    flow:
      - function: "generateLeadPayload"
      - post:
          url: "/api/v1/leads"
          json:
            vertical: "{{ vertical }}"
            geo:
              country: "{{ country }}"
              state: "{{ state }}"
              zip: "{{ zip }}"
            firstName: "Reorg"
            lastName: "Sim{{ $randomInt(1, 99999) }}"
            email: "reorg{{ $randomInt(1, 99999) }}@test.com"
            phone: "+1555{{ $randomInt(1000000, 9999999) }}"
            source: "API"
          capture:
            - json: "$.id"
              as: "leadId"
          expect:
            - statusCode: 201
      # First bid
      - function: "generateBidCommitment"
      - post:
          url: "/api/v1/bids"
          json:
            leadId: "{{ leadId }}"
            amount: "{{ bidAmount }}"
            commitment: "{{ commitment }}"
          expect:
            - statusCode:
                - 201
                - 200
      # Attempt to "cancel" by re-bidding with zero (edge case)
      - post:
          url: "/api/v1/bids"
          json:
            leadId: "{{ leadId }}"
            amount: 0
            commitment: "0x0000000000000000000000000000000000000000000000000000000000000000"
          expect:
            - statusCode:
                - 400  # Invalid bid
                - 409  # Already bid
                - 422  # Validation error
      # Re-bid with new amount (simulating reorg recovery)
      - function: "generateBidCommitment"
      - post:
          url: "/api/v1/bids"
          json:
            leadId: "{{ leadId }}"
            amount: "{{ bidAmount }}"
            commitment: "{{ commitment }}"
          afterResponse: "validateResponse"
          expect:
            - statusCode:
                - 201
                - 200
                - 409  # Already has valid bid

  # ─── 2. Cache Bypass (Redis Outage Sim) ────────
  # Force all requests to hit DB directly by adding skip-cache header
  - name: "Cache Bypass (Redis Outage)"
    weight: 20
    flow:
      - get:
          url: "/api/v1/leads?page=1&limit=50"
          headers:
            X-Skip-Cache: "true"
          afterResponse: "trackCacheBypassMetrics"
          expect:
            - statusCode: 200
      - think: 0.2
      - function: "pickRandomVertical"
      - get:
          url: "/api/v1/leads?vertical={{ vertical }}&page=1&limit=50"
          headers:
            X-Skip-Cache: "true"
          afterResponse: "trackCacheBypassMetrics"
          expect:
            - statusCode: 200
      # Bid floor without cache — forces fresh computation
      - get:
          url: "/api/v1/bids/bid-floor?vertical={{ vertical }}&country=US"
          headers:
            X-Skip-Cache: "true"
          afterResponse: "trackCacheBypassMetrics"
          expect:
            - statusCode: 200

  # ─── 3. Chainlink Stub Latency > 5s ────────────
  # Exercises timeout handling when Chainlink services respond slowly
  - name: "Chainlink Stub Slow Response"
    weight: 15
    flow:
      - function: "simulateChainlinkLatency"
      # CRE verification with simulated 6s delay
      - get:
          url: "/api/v1/bids/bid-floor?vertical=solar&country=US&stubDelay=6000"
          afterResponse: "trackLatencyMetrics"
          expect:
            - statusCode:
                - 200  # Stub returns cached result
                - 504  # Gateway timeout
      # DECO attestation with simulated 7s delay
      - post:
          url: "/api/v1/demo/compliance-check"
          json:
            buyerWallet: "0xSlowTest{{ $randomInt(1000, 9999) }}"
            sellerCountry: "DE"
            buyerCountry: "US"
            vertical: "solar"
          afterResponse: "trackLatencyMetrics"
          expect:
            - statusCode:
                - 200
                - 504
      # Multi-step: submit lead → verify (slow) → bid
      - function: "generateLeadPayload"
      - post:
          url: "/api/v1/leads"
          json:
            vertical: "solar"
            geo:
              country: "{{ country }}"
              state: "{{ state }}"
            firstName: "SlowChain"
            lastName: "Test{{ $randomInt(1, 99999) }}"
            email: "slow{{ $randomInt(1, 99999) }}@test.com"
            phone: "+1555{{ $randomInt(1000000, 9999999) }}"
            source: "API"
          capture:
            - json: "$.id"
              as: "leadId"
          expect:
            - statusCode: 201

  # ─── 4. Concurrent Budget Drain ────────────────
  # 10 auto-bid evaluations in rapid succession to drain daily budget
  - name: "Concurrent Budget Drain"
    weight: 20
    flow:
      - loop:
          - function: "generateAutoBidBudgetExhaust"
          - post:
              url: "/api/v1/bids/auto-bid/evaluate"
              json:
                leadId: "{{ leadId }}"
              afterResponse: "trackBudgetMetrics"
              expect:
                - statusCode:
                    - 200  # Evaluated (may have bidsPlaced or skipped)
                    - 400  # Validation error
                    - 401  # Auth required
          - think: 0.05  # Very rapid — simulates concurrent auto-bid evaluation
        count: 10

  # ─── 5. Webhook Failure Cascade ────────────────
  # Register webhook to non-existent URL, fire events, verify graceful degradation
  - name: "Webhook Failure Cascade"
    weight: 20
    flow:
      # Register webhook to a URL that will fail
      - post:
          url: "/api/v1/crm/webhooks"
          json:
            url: "https://nonexistent-webhook-target.invalid/hook"
            format: "generic"
            events:
              - "lead.sold"
          afterResponse: "trackWebhookMetrics"
          expect:
            - statusCode:
                - 201
                - 200
                - 429
      # Register a second webhook (HubSpot format) to another bad URL
      - post:
          url: "/api/v1/crm/webhooks"
          json:
            url: "https://timeout-simulation.invalid/hubspot"
            format: "hubspot"
            events:
              - "lead.sold"
              - "lead.created"
          afterResponse: "trackWebhookMetrics"
          expect:
            - statusCode:
                - 201
                - 200
                - 429
      # List webhooks — should still work despite bad targets
      - get:
          url: "/api/v1/crm/webhooks"
          expect:
            - statusCode: 200
      # Submit a lead (triggers lead.created webhook to bad URL)
      - function: "generateLeadPayload"
      - post:
          url: "/api/v1/leads"
          json:
            vertical: "{{ vertical }}"
            geo:
              country: "{{ country }}"
              state: "{{ state }}"
            firstName: "WebhookFail"
            lastName: "Cascade{{ $randomInt(1, 99999) }}"
            email: "whfail{{ $randomInt(1, 99999) }}@test.com"
            phone: "+1555{{ $randomInt(1000000, 9999999) }}"
            source: "API"
          afterResponse: "validateResponse"
          expect:
            - statusCode: 201  # Lead creation should succeed despite webhook failures
